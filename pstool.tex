\RequirePackage{filecontents}
\begin{filecontents*}{README.txt}
__________________
The pstool package
v0.2

A package like "pst-pdf" for processing PostScript graphics 
within pdfLaTeX documets. The difference with this package 
is that every graphic is processed separately, drastically 
speeding up compilation time.

Running `latex` on pstool.tex will produce pstool.sty and pstool.drv. 
Executing `pdflatex pstool.drv` produces the typeset documentation.

Will Robertson & Zebb Prime
Copyright 2008
\end{filecontents*}

\begin{filecontents*}{pstool.sty}
\ProvidesPackage{pstool}[2008/08/03 v0.2 Wrapper for processing PostScript/psfrag figures]

% Initialisations
\newif\if@pstool@always@
\newif\if@pstool@never@
\newif\if@pstool@pdfcrop@
\newwrite\pstool@out

% Package options
\RequirePackage{xkeyval}
\DeclareOptionX{pdfcrop}{\@pstool@pdfcrop@true}

\define@choicekey *{pstool.sty}{process}[\@tempa\@tempb]{all,none,auto}{% 
  \ifcase\@tempb\relax 
    \@pstool@always@true
  \or 
    \@pstool@never@true 
  \or
  \fi} 

\ProcessOptionsX

% External packages
\RequirePackage{catchfile,color,ifpdf,ifplatform,inversepath,graphicx,suffix}

% These are cute:
\providecommand\OnlyIfFileExists[2]{\IfFileExists{#1}{#2}{}}
\providecommand\NotIfFileExists[2]{\IfFileExists{#1}{}{#2}}

% Command line abstractions between platforms:
\edef\pstool@cmdsep{\ifwindows\string&\else\string;\fi\space}
\edef\pstool@rm{\ifwindows del \else rm -- \fi}

\newcommand\pstool@try@rm[1]{%
  \begingroup
    \@for\@tempa:=#1\do{%
      \OnlyIfFileExists{\ip@directpath\@tempa}{%
        \immediate\write18{%
          cd "\ip@directpath"\pstool@cmdsep 
          \pstool@rm "\@tempa"}}}%
  \endgroup}

% Generic function to execute a command on the shell and pass its exit status back into \LaTeX. Any number of \cmd\pstool@exe\ statements can be made consecutively followed by \cmd\pstool@endprocess, which also takes an argument. If \emph{any} of the shell calls failed, then the execution immediately skips to the end and expands \cmd\pstool@error\ instead of the argument to \cmd\pstool@endprocess.
\def\pstool@exe#1{%
  \immediate\write18{%
    cd "\ip@directpath"\pstool@cmdsep 
    \pstool@writestatus{#1}%
  }%
  \pstool@retrievestatus\@tempa
  \ifnum\@tempa > 0
    \PackageWarning{pstool}{Execution failed during process:^^J  #1^^J}%
    \expandafter\pstool@abort
  \fi}

% Edit this definition to print something else when graphic processing fails.
\def\pstool@error#1{\fbox{\color{red}\ttfamily An error occured processing this graphic.}}

\def\pstool@abort#1\pstool@endprocess{\pstool@error}
\let\pstool@endprocess\@firstofone

% It is necessary while executing commands on the shell to write the exit status to a temporary file to test for failures in processing. \verb|#1 & echo %ERRORLEVEL%| doesn't return the correct value inside a \cs{write18} in Windows, so we have to do something different there.
\def\pstool@statusfile{status-deleteme.txt}
\def\pstool@writestatus#1{%
  \ifwindows
    echo 0 > \pstool@statusfile\pstool@cmdsep
    #1 \detokenize{||} echo 1 > \pstool@statusfile
  \else
    #1\pstool@cmdsep echo $? > \pstool@statusfile
  \fi
}

% Read the exit status from the temporary file and delete it.
\def\pstool@retrievestatus#1{%
  \pstool@touchstatus
  \CatchFileEdef{#1}{\ip@directpath\pstool@statusfile}{}%
  \pstool@try@rm{\pstool@statusfile}%
}

% This ensures the file is written to disk properly (allowing it to be read by \cmd\CatchFileEdef). Not necessary on Windows, whose file writing is evidently more crude/immediate.
\def\pstool@touchstatus{%
  \ifwindows\else
    \immediate\write18{%
      cd "\ip@directpath"\pstool@cmdsep 
      touch \pstool@statusfile}%
  \fi
}

% \subsection{File age detection}
% Use \texttt{ls} (or \texttt{dir}) to detect if the EPS is newer than the PDF:
\def\pstool@datefiles{%
  \edef\pstool@filenames{\ip@lastelement.eps\space \ip@lastelement.pdf\space}%
  \immediate\write18{%
    cd "\ip@directpath"\pstool@cmdsep     
    \ifwindows
      dir /T:W /B /O-D "\ip@lastelement.eps" "\ip@lastelement.pdf" > \pstool@statusfile
    \else
      ls -t "\ip@lastelement.eps" "\ip@lastelement.pdf" > \pstool@statusfile
    \fi
  }%
  \pstool@retrievestatus\@tempa
  \ifx\@tempa\pstool@filenames
    \@tempswatrue
  \else
    \@tempswafalse
  \fi
}


% \section{Command parsing}
% User input is \cmd\psfig\ (with optional \texttt* or \texttt! suffix) which turns into one of the following three macros depending on the mode.

\newcommand\pstool@alwaysprocess[3][]{%
  \inversepath*{#2}% calculate filename, path \& inverse path
  \pstool@process[#1]{#2}{#3}}

\newcommand\pstool@neverprocess[3][]{%
  \includegraphics[#1]{#2}}

% For regular operation, which processes the figure only if
% the command is starred, or the PDF doesn't exist.
\newcommand\pstool@maybeprocess[3][]{%
  \inversepath*{#2}% calculate filename, path \& inverse path
  \IfFileExists{#2.pdf}{%
    \pstool@datefiles
    \if@tempswa\expandafter\@firstoftwo
      \else\expandafter\@secondoftwo\fi{%
        \pstool@process[#1]{#2}{#3}%
      }{%
        \includegraphics[#1]{#2}}%
  }{%
    \pstool@process[#1]{#2}{#3}%
  }}

% \subsection{User commands}
%  Finally, define \cmd\psfig\ as appropriate for the mode:
\ifpdf
  \if@pstool@always@
    \let\psfig\pstool@alwaysprocess
    \WithSuffix\def\psfig!{\pstool@alwaysprocess}
    \WithSuffix\def\psfig*{\pstool@alwaysprocess}
  \else\if@pstool@never@
    \let\psfig\pstool@neverprocess
    \WithSuffix\def\psfig!{\pstool@neverprocess}
    \WithSuffix\def\psfig*{\pstool@neverprocess}
  \else
    \let\psfig\pstool@maybeprocess
    \WithSuffix\def\psfig!{\pstool@neverprocess}
    \WithSuffix\def\psfig*{\pstool@alwaysprocess}
  \fi\fi
\else
  \let\psfig\pstool@neverprocess
  \WithSuffix\def\psfig!{\pstool@neverprocess}
  \WithSuffix\def\psfig*{\pstool@neverprocess}
\fi

% \section{The figure processing}
\newcommand{\pstool@process}[3][]{%
  \pstool@write@processfile{#1}{#2}{#3}%
  \pstool@exe{latex -shell-escape -output-format=dvi 
      -interaction=batchmode "\ip@lastelement-process.tex"}%
  \pstool@exe{dvips "\ip@lastelement-process.dvi"}%
  \if@pstool@pdfcrop@
    \pstool@exe{ps2pdf "\ip@lastelement-process.ps" "\ip@lastelement-process.pdf"}%
    \pstool@exe{pdfcrop "\ip@lastelement-process.pdf" "\ip@lastelement.pdf"}%
  \else
    \pstool@exe{ps2pdf "\ip@lastelement-process.ps" "\ip@lastelement.pdf"}%
  \fi
  \pstool@endprocess{\includegraphics[#1]{#2}}}

% The file that is written for processing is set up to read the preamble of the original document and set the graphic on an empty page (cropping to size is done either here with \pkg{preview} or later with \pkg{pdfcrop}).
\def\pstool@write@processfile#1#2#3{%
    \immediate\openout\pstool@out #2-process.tex\relax
    \immediate\write\pstool@out{%
      \unexpanded{%
        \pdfoutput=0% force DVI mode if not already
%
% Input the main document; redefine the document environment so only the preamble is read:
        \let\origdocument\document
        \def\document{\endgroup\endinput}%
      }\noexpand
        \input{\ip@inversepath\jobname}%
%
% Now the preamble of the process file: (restoring document's original meaning)
      \if@pstool@pdfcrop@\else
        \noexpand\usepackage[active,tightpage]{preview}
      \fi
      \unexpanded{%
        \let\document\origdocument
        \pagestyle{empty}% remove the page number
        \begin{document}
%
% And the document body to place the graphic on a page of its own:
        \centering\null\vfill}%
      \if@pstool@pdfcrop@\else
        \noexpand\begin{preview}%
      \fi
        \unexpanded{#3}% this is the "psfrag" material
        \noexpand\includegraphics[#1]{\ip@lastelement}%
      \if@pstool@pdfcrop@\else
        \noexpand\end{preview}%
      \fi        
      \unexpanded{%
        \vfill\end{document}}%
      }%
    \immediate\closeout\pstool@out}

\end{filecontents*}

\begin{filecontents*}{pstool.drv}
\immediate\write18{makeindex -r \jobname}
\immediate\write18{makeindex -r -s gmglo.ist -o \jobname.gls \jobname.glo}

\makeatletter
\documentclass{article}
\usepackage{xcolor}
\usepackage[colorlinks]{hyperref}
\usepackage{gmdoc}

\stanzaskip=\bigskipamount

\begin{obeyspaces}% 
\gdef\CodeSpacesGrey{% 
\def\gmd@DoTeXCodeSpace{% 
\obeyspaces\def {\texttt{\color{gray}\char`\ }}}% 
\def\gmd@texcodespace{\texttt{\color{gray}\char`\ }}}% 
\end{obeyspaces} 
\CodeSpacesGrey

\let\pkg\textsf
\def\pkgopt#1{\texttt{[#1]}}

\def\PDF{\textsc{pdf}}
\def\PS{\textsc{ps}}
\def\DVI{\textsc{dvi}}
\def\EPS{\textsc{eps}}

\usepackage{amsmath}
\usepackage{pstool}
\usepackage[T1]{fontenc}
\usepackage{microtype}
\usepackage{lmodern}
\usepackage[sc,osf]{mathpazo}
\GetFileInfo{pstool.sty}
\date{\fileversion\qquad\filedate}
\begin{document}

\title{The pstool package}
\author{Will Robertson and Zebb Prime}
\maketitle

\tableofcontents

\part{Documentation}

\section{Introduction}

While pdf\/\LaTeX\ is a great improvement in many ways over the `old method' of \DVI$\to$\PS$\to$\PDF, it loses the ability to interface with a generic PostScript workflow, used to great effect in numerous packages, most notably \pkg{PSTricks} and \pkg{psfrag}.

Until now, the best way to use these packages while running pdf\/\LaTeX\ has been to use the \pkg{pst-pdf} package, which processes the entire document through a filter, sending each relevant PostScript environment through \DVI$\to$\PS$\to$\PDF. The resulting \PDF\ versions of each image are then included into the pdf\/\LaTeX\ document. The \pkg{auto-pst-pdf} package provided a wrapper to execute this separate process automatically.

The disadvantage in this route is that for every document compilation, \emph{every} graphic must be re-processed. The \pkg{pstool} package uses a different approach to allow each graphic to be processed only as-needed, speeding up and simplifying the typesetting of the main document.

\section{Processing modes}

The main command provided by this package is\\\hspace*{4em}\cmd\psfig\arg[graphicx options]\arg{filename}\arg{graphic data}.\\ By default it can be used in the following modes:
\begin{description}
\item[\cs{psfig}] Process the graphic \<filename> if no \PDF\ of the same name exists, or the source \EPS\ file is \emph{newer} than the \PDF;
\item[\cs{psfig*}] Always process this figure; and,
\item[\cs{psfig!}] Never process this figure.
\end{description}
The following package options override the above: 
\pkgopt{process=all}, 
\pkgopt{process=none} (the default is \pkgopt{process=auto}).

\section{Cropping graphics}
Graphics are cropped to the appropriate size with the \pkg{preview} package. Sometimes, however, this will not be good enough when an inserted label protrudes from the natural bounding box of the figure. A good way to solve this problem is to use the \pkg{pdfcrop} program (requires a Perl installation under Windows). This can be activated in \pkg{pstool} with the \pkgopt{pdfcrop} package option.

\section{Todo} 
\begin{enumerate}
\item Higher commands (\cmd\psfragfig, \cmd\matlabfig, \cmd\mathfig)
\item Generalise "olding" code for multiple files.
\item Basic \EPS$\to$\PDF\ processing (no need to read in the document preamble).
\item Check for correct behaviour in shells other than bash.
\item More flexible usage (support things like \verb|\begin{postscript}| in \pkg{pst-pdf}).
\item mylatex integration
\end{enumerate}

\part{Implementation}
\parindent=0pt
\DocInput{pstool.sty}
\end{document}
\end{filecontents*}

\csname@@end\endcsname