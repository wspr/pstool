\RequirePackage{filecontents}
\begin{filecontents*}{README.txt}
__________________
The pstool package
v0.5

A package like "pst-pdf" for processing PostScript graphics 
within pdfLaTeX documets. The difference with this package 
is that every graphic is processed separately, drastically 
speeding up compilation time.

Running `latex` on pstool.tex will produce the files
  pstool.ins, pstool.sty, and README.txt,
and compile the PDF documentation. 

Executing `tex pstool.ins` produces the files above 
except pstool.ins.

Will Robertson & Zebb Prime
Copyright 2008
\end{filecontents*}

\begin{filecontents*}{pstool.sty}
\ProvidesPackage{pstool}[2008/08/08 v0.5 
  Wrapper for processing PostScript/psfrag figures]

% External packages
\RequirePackage{%
  catchfile,color,ifpdf,ifplatform,
  inversepath,graphicx,suffix,xkeyval}

% Initialisations
\newif\if@pstool@always@
\newif\if@pstool@never@
\newif\if@pstool@pdfcrop@
\newif\if@pstool@nopreamble@
\newif\if@pstool@nofig@
\newwrite\pstool@out

% Package options
\DeclareOptionX{pdfcrop}{\@pstool@pdfcrop@true}

\define@choicekey*{pstool.sty}{process}[\@tempa\@tempb]{all,none,auto}{% 
  \ifcase\@tempb\relax 
    \@pstool@always@true
  \or 
    \@pstool@never@true 
  \or
  \fi} 

\DeclareOptionX{cleanup}{%
  \def\pstool@rm@files{#1}}
\ExecuteOptionsX{cleanup={tex,dvi,ps,pdf,log,aux}}

\DeclareOptionX{suffix}{\def\pstool@suffix{#1}}
\ExecuteOptionsX{suffix={-process}}

\ifshellescape\else
  \ExecuteOptionsX{process=none}
  \PackageWarning{pstool}{^^J\space\space%
    Package option [process=none] activated^^J\space\space 
    because -shell-escape is not enabled.^^J%
    This warning occurred}
\fi

\ProcessOptionsX

% These are cute:
\providecommand\OnlyIfFileExists[2]{\IfFileExists{#1}{#2}{}}
\providecommand\NotIfFileExists[2]{\IfFileExists{#1}{}{#2}}

% Command line abstractions between platforms:
\edef\pstool@cmdsep{\ifwindows\string&\else\string;\fi\space}
\edef\pstool@rm@cmd{\ifwindows del \else rm -- \fi}

% Delete a file if it exists:
\newcommand\pstool@rm[1]{%
  \OnlyIfFileExists{\ip@directpath#1}{%
    \immediate\write18{%
      cd "\ip@directpath"\pstool@cmdsep\pstool@rm@cmd "#1"}}%
}

% Generic function to execute a command on the shell and pass its exit status back into \LaTeX. Any number of \cmd\pstool@exe\ statements can be made consecutively followed by \cmd\pstool@endprocess, which also takes an argument. If \emph{any} of the shell calls failed, then the execution immediately skips to the end and expands \cmd\pstool@error\ instead of the argument to \cmd\pstool@endprocess.
\def\pstool@exe#1{%
  \immediate\write18{%
    cd "\ip@directpath"\pstool@cmdsep 
    \pstool@writestatus{#1}%
  }%
  \pstool@retrievestatus\@tempa
  \ifnum\@tempa > 0
    \PackageWarning{pstool}{Execution failed during process:^^J  #1^^J}%
    \expandafter\pstool@abort
  \fi}

% Edit this definition to print something else when graphic processing fails.
\def\pstool@error#1{\fbox{\color{red}\ttfamily\scshape 
  An error occured processing this graphic.}}

\def\pstool@abort#1\pstool@endprocess{\pstool@error}
\let\pstool@endprocess\@firstofone

% It is necessary while executing commands on the shell to write the exit status to a temporary file to test for failures in processing. (If all versions of |pdflatex| supported input pipes, things might be different.)
\def\pstool@statusfile{status-deleteme.txt}
\def\pstool@writestatus#1{%
  \ifwindows
    #1 \pstool@cmdsep call echo 
      \string^\@percentchar ERRORLEVEL\string^\@percentchar 
      > \pstool@statusfile
  \else
    #1 \pstool@cmdsep echo \detokenize{$?} > \pstool@statusfile
  \fi
}

% Read the exit status from the temporary file and delete it.
\def\pstool@retrievestatus#1{%
  \pstool@touchstatus
  \CatchFileEdef{#1}{\ip@directpath\pstool@statusfile}{}%
  \pstool@rm{\pstool@statusfile}%
}

% This ensures the file is written to disk properly (allowing it to be read by \cmd\CatchFileEdef). Not necessary on Windows, whose file writing is evidently more crude/immediate.
\def\pstool@touchstatus{%
  \ifwindows\else
    \immediate\write18{%
      cd "\ip@directpath"\pstool@cmdsep 
      touch \pstool@statusfile}%
  \fi
}

% \subsection{File age detection}
% Use |ls| (or |dir|) to detect if the EPS is newer than the PDF:
\def\pstool@datefiles{%
  \edef\pstool@filenames{\ip@lastelement.eps\space \ip@lastelement.pdf\space}%
  \immediate\write18{%
    cd "\ip@directpath"\pstool@cmdsep     
    \ifwindows
      dir /T:W /B /O-D "\ip@lastelement.eps" "\ip@lastelement.pdf" > \pstool@statusfile
    \else
      ls -t "\ip@lastelement.eps" "\ip@lastelement.pdf" > \pstool@statusfile
    \fi
  }%
  \pstool@retrievestatus\@tempa
  \ifx\@tempa\pstool@filenames
    \@tempswatrue
  \else
    \@tempswafalse
  \fi
}


% \section{Command parsing}
% User input is \cmd\pstool\ (with optional |*| or |!| suffix) which turns into one of the following three macros depending on the mode.

\newcommand\pstool@alwaysprocess[3][]{%
  \inversepath*{#2}% calculate filename, path \& inverse path
  \pstool@process[#1]{#2}{#3}}

\newcommand\pstool@neverprocess[3][]{%
  \includegraphics[#1]{#2}}

% For regular operation, which processes the figure only if
% the command is starred, or the PDF doesn't exist.
\newcommand\pstool@maybeprocess[3][]{%
  \inversepath*{#2}% calculate filename, path \& inverse path
  \IfFileExists{#2.pdf}{%
    \pstool@datefiles
    \if@tempswa\expandafter\@firstoftwo
      \else\expandafter\@secondoftwo\fi{%
        \pstool@process[#1]{#2}{#3}%
      }{%
        \includegraphics[#1]{#2}}%
  }{%
    \pstool@process[#1]{#2}{#3}%
  }}

% \subsection{User commands}
%  Finally, define \cmd\pstool\ as appropriate for the mode:
\ifpdf
  \if@pstool@always@
    \let\pstool\pstool@alwaysprocess
    \WithSuffix\def\pstool!{\pstool@alwaysprocess}
    \WithSuffix\def\pstool*{\pstool@alwaysprocess}
  \else\if@pstool@never@
    \let\pstool\pstool@neverprocess
    \WithSuffix\def\pstool!{\pstool@neverprocess}
    \WithSuffix\def\pstool*{\pstool@neverprocess}
  \else
    \let\pstool\pstool@maybeprocess
    \WithSuffix\def\pstool!{\pstool@neverprocess}
    \WithSuffix\def\pstool*{\pstool@alwaysprocess}
  \fi\fi
\else
  \let\pstool\pstool@neverprocess
  \WithSuffix\def\pstool!{\pstool@neverprocess}
  \WithSuffix\def\pstool*{\pstool@neverprocess}
\fi

% \section{The figure processing}

% \cmd\ip@lastelement\ is the filename of the figure stripped of its path (if any)
\def\pstool@jobname{\ip@lastelement\pstool@suffix}

\newcommand{\pstool@process}[3][]{%
  \pstool@write@processfile{#1}{#2}{#3}%
  \pstool@exe{latex -shell-escape -output-format=dvi 
      -interaction=batchmode "\pstool@jobname.tex"}%
  \pstool@exe{dvips "\pstool@jobname.dvi"}%
  \if@pstool@pdfcrop@
    \pstool@exe{ps2pdf "\pstool@jobname.ps" "\pstool@jobname.pdf"}%
    \pstool@exe{pdfcrop "\pstool@jobname.pdf" "\ip@lastelement.pdf"}%
  \else
    \pstool@exe{ps2pdf "\pstool@jobname.ps" "\ip@lastelement.pdf"}%
  \fi
  \pstool@endprocess{%
    \pstool@cleanup
    \includegraphics[#1]{#2}}}

% The file that is written for processing is set up to read the preamble of the original document and set the graphic on an empty page (cropping to size is done either here with \pkg{preview} or later with \pkg{pdfcrop}).
\def\pstool@write@processfile#1#2#3{%
    \immediate\openout\pstool@out #2-process.tex\relax
    \immediate\write\pstool@out{%
      \noexpand\pdfoutput=0% force DVI mode if not already
%
% Input the main document; redefine the document environment so only the preamble is read:
      \if@pstool@nopreamble@
        \unexpanded{%
          \documentclass{minimal}
          \usepackage{graphicx}}
      \else
        \unexpanded{%
          \let\origdocument\document
          \def\document{\endgroup\endinput}}%
        \noexpand
          \input{\ip@inversepath\jobname}%
      \fi
%
% Now the preamble of the process file: (restoring document's original meaning; empty \cmd\pagestyle\ removes the page number)
      \if@pstool@pdfcrop@\else
        \noexpand\usepackage[active,tightpage]{preview}
      \fi
      \if@pstool@nopreamble@\else
        \unexpanded{%
          \let\document\origdocument
          \pagestyle{empty}}%
      \fi
%
% And the document body to place the graphic on a page of its own:
      \unexpanded{%
        \begin{document}
        \centering\null\vfill}%
      \if@pstool@pdfcrop@\else
        \noexpand\begin{preview}%
      \fi
      \unexpanded{#3}% this is the "psfrag" material
      \if@pstool@nofig@\else
        \noexpand\includegraphics[#1]{\ip@lastelement}%
      \fi
      \if@pstool@pdfcrop@\else
        \noexpand\end{preview}%
      \fi        
      \unexpanded{%
        \vfill\end{document}}%
      }%
    \immediate\closeout\pstool@out}

\def\pstool@cleanup{%
  \@for\@ii:=\pstool@rm@files\do{%
    \pstool@rm{\pstool@jobname.\@ii}%
}}

% \section{User commands}
%
% These all support the suffixes |*| and |!|, so each user command is defined as a wrapper to \cmd\pstool.

% for plain EPS figures (no psfrag):
\newcommand\epsfig[2][]{\pstool@epsfig{\pstool}[#1]{#2}}
\WithSuffix\newcommand\epsfig*[2][]{\pstool@epsfig{\pstool*}[#1]{#2}}
\WithSuffix\newcommand\epsfig![2][]{\pstool@epsfig{\pstool!}[#1]{#2}}

\def\pstool@epsfig#1[#2]#3{%
  \begingroup
    \@pstool@nopreamble@true
    #1[#2]{#3}{}%
  \endgroup
}

% for EPS figures with psfrag:
\newcommand\psfragfig[2][]{\pstool@psfragfig{\pstool}[#1]{#2}}
\WithSuffix\newcommand\psfragfig*[2][]{\pstool@psfragfig{\pstool*}[#1]{#2}}
\WithSuffix\newcommand\psfragfig![2][]{\pstool@psfragfig{\pstool!}[#1]{#2}}

\def\pstool@psfragfig#1[#2]#3{%
  \@ifnextchar\bgroup{%
    \pstool@@psfragfig{#1}[#2]{#3}%
  }{%
    \pstool@@psfragfig{#1}[#2]{#3}{}%
  }%
}

\def\pstool@@psfragfig#1[#2]#3#4{%
  #1[#2]{#3}{%
    \InputIfFileExists{#3-psfrag}{}{}%
    #4}%
}

% for Matlab's laprint:
\newcommand\laprintfig[2][]{\pstool@laprintfig{\pstool}[#1]{#2}}
\WithSuffix\newcommand\laprintfig*[2][]{\pstool@laprintfig{\pstool*}[#1]{#2}}
\WithSuffix\newcommand\laprintfig![2][]{\pstool@laprintfig{\pstool!}[#1]{#2}}

\def\pstool@laprintfig#1[#2]#3{%
  \begingroup
    \@pstool@nofig@true
    \renewcommand\resizebox[3]{##3}%
    \renewcommand\includegraphics[2][]{#1[#2]{##2}{}}%
    \input{#3}%
  \endgroup
}

% for Mathematica's MathPSfrag:
\newcommand\mathpsfragfig[2][]{\pstool@mathpsfragfig{\pstool}[#1]{#2}}
\WithSuffix\newcommand\mathpsfragfig*[2][]{\pstool@mathpsfragfig{\pstool*}[#1]{#2}}
\WithSuffix\newcommand\mathpsfragfig![2][]{\pstool@mathpsfragfig{\pstool!}[#1]{#2}}

\def\pstool@mathpsfragfig#1[#2]#3{%
  #1[#2]{#3-psfrag}{\input{#3-psfrag}}%
}

\end{filecontents*}





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Conditionally compile the documentation & generate the .ins file:
\providecommand\pstoolCompile{Y}
\expandafter\ifx\pstoolCompile N
  \expandafter\endinput
\fi

\begin{filecontents*}{pstool.ins}
%&latex
\newcommand\pstoolCompile{N}
\input pstool.tex
\csname@@end\endcsname
\end{filecontents*}

\immediate\write18{makeindex -r \jobname}
\immediate\write18{makeindex -r -s gmglo.ist -o \jobname.gls \jobname.glo}

\makeatletter
\documentclass{article}
\usepackage{xcolor}
\usepackage[colorlinks]{hyperref}
\usepackage{gmdoc}
\usepackage{gmverb}

\dekclubs
\stanzaskip=\bigskipamount

\begin{obeyspaces}% 
\gdef\CodeSpacesGrey{% 
\def\gmd@DoTeXCodeSpace{% 
\obeyspaces\def {\texttt{\color{gray}\char`\ }}}% 
\def\gmd@texcodespace{\texttt{\color{gray}\char`\ }}}% 
\end{obeyspaces} 
\CodeSpacesGrey

\let\pkg\textsf
\def\pkgopt#1{\texttt{[#1]}}

\def\PDF{\textsc{pdf}}
\def\PS{\textsc{ps}}
\def\DVI{\textsc{dvi}}
\def\EPS{\textsc{eps}}

\usepackage{amsmath}
\usepackage{pstool}
\usepackage[T1]{fontenc}
\usepackage{microtype}
\usepackage{lmodern}
\usepackage[sc,osf]{mathpazo}
\linespread{1.1}
\GetFileInfo{pstool.sty}
\date{\fileversion\qquad\filedate}
\begin{document}

\title{The \pkg{pstool} package}
\author{Will Robertson and Zebb Prime}
\maketitle

\tableofcontents

\part{Documentation}

\section{Introduction}

While pdf\/\LaTeX\ is a great improvement in many ways over the `old method' of \DVI$\to$\PS$\to$\PDF, it loses the ability to interface with a generic PostScript workflow, used to great effect in numerous packages, most notably \pkg{PSTricks} and \pkg{psfrag}.

Until now, the best way to use these packages while running pdf\/\LaTeX\ has been to use the \pkg{pst-pdf} package, which processes the entire document through a filter, sending the relevant PostScript environments through a single pass of \DVI$\to$\PS$\to$\PDF. The resulting \PDF\ versions of each image are then included into the pdf\/\LaTeX\ document. The \pkg{auto-pst-pdf} package provides a wrapper to perform all of this automatically.

The disadvantage with this method is that for every document compilation, \emph{every} graphic must be re-processed. The \pkg{pstool} package uses a different approach to allow each graphic to be processed only as-needed, speeding up and simplifying the typesetting of the main document.

\section{Processing modes}

The generic command provided by this package is
\begin{center}
  \cmd\pstool\arg[graphicx options]\arg{filename}\arg{input definitions}
\end{center}
It converts the graphic \<filename>|.eps| to \<filename>|.pdf| through a unique \DVI$\to$\PS$\to$\PDF\ process for each graphic, using the preamble of the main document. The resulting graphic is then inserted into the document, with optional \<graphicx options>. The third argument to \cmd\pstool\ allows arbitrary \<input definitions> (such as \cmd\psfrag\ directives) to be inserted before the figure as it is processed. 

By default \cmd\pstool\ can be used in the following modes:
\begin{description}
\item[\cs{pstool}] Process the graphic \<filename> if no \PDF\ of the same name exists, or if the source \EPS\ file is \emph{newer} than the \PDF;
\item[\cs{pstool*}] Always process this figure; and,
\item[\cs{pstool!}] Never process this figure.
\end{description}

The package accepts options to override the above: 
\begin{description}
\item[\pkgopt{process=auto}] This is the default as described above;
\item[\pkgopt{process=all}] All \cmd\pstool\ graphics are processed regardless of suffix; and,
\item[\pkgopt{process=none}] No \cmd\pstool\ graphics are processed.%
\footnote{If \pkg{pstool} is loaded in a \LaTeX\ document in \DVI\ mode, this is the option that is used since no external processing is required for these graphics.}
\end{description}

It is useful to define higher-level commands with \cmd\pstool\ for including specific types of \EPS\ graphics that take advantage of \pkg{psfrag}. As an example, this package defines the following commands. These commands all support the |*| or |!| suffices.
\begin{description}
\item[{\cmd\epsfig\arg[opts]\arg{filename}}] 
Insert a plain \EPS\ figure. It is more convenient than using, for example, the \pkg{epstopdf} package since it will regenerate the \PDF\ if the \EPS\ file changes.

\item[{\cmd\psfragfig\arg[opts]\arg{filename}}] 
Insert an \EPS\ file with \pkg{psfrag} definitions contained within the file \<filename>|-psfrag.tex|. (Accepts an optional braced argument as shown next.)

\item[{\cmd\psfragfig\arg[opts]\arg{filename}\arg{input definitions}}] 
Insert an \EPS\ file with \pkg{psfrag} definitions contained either/or within the file \<filename>|-psfrag.tex| and supplied by the third argument \<input definitions>.

\item[{\cmd\laprintfig\arg[opts]\arg{filename}}] 
Insert figures that have been produced with \textsc{Matlab}'s \pkg{laprint} package.

\item[{\cmd\mathpsfragfig\arg[opts]\arg{filename}}] 
Insert figures that have been produced with \textsc{Mathematica}'s \pkg{MathPSfrag} package. Automatically adds the |-psfrag| suffix to the \<filename>.
\end{description}

\section{Package options}

\subsection{Cropping graphics}
Graphics are cropped to the appropriate size with the \pkg{preview} package. Sometimes, however, this will not be good enough when an inserted label protrudes from the natural bounding box of the figure. A good way to solve this problem is to use the \pkg{pdfcrop} program (requires a Perl installation under Windows). This can be activated in \pkg{pstool} with the \pkgopt{pdfcrop} package option.

\subsection{Temporary files \& cleanup}
Each figure that is processed spawns an auxiliary \LaTeX\ compilation through \DVI$\to$\PS$\to$\PDF. This process is named after the name of the figure with a suffix; the default is \pkgopt{suffix=\{-process\}}. All of these suffixed files are ``temporary'' in that they may be deleted once they are no longer needed.

As an example, if the figure is called |ex.eps|, the files that are created are |ex-process.tex|, |ex-process.dvi|, \dots. The \pkgopt{cleanup} package option declares via a list of extensions which temporary files are to be deleted after processing.

By default, this is \pkgopt{cleanup=\{tex,dvi,ps,pdf,log,aux\}}. Choose \pkgopt{cleanup=\{\}} to delete none of the temporary files (useful for debugging).

\section{Todo} 
\begin{enumerate}
\item Test \cmd\laprint, \cmd\psfragfig, \cmd\matlabfig, \cmd\mathfig, 
       especially with figures in a relative path.
\item Generalise ``process if older'' code for multiple files.
\item Support optional \<input definitions> for all user commands??
\item (Maybe) support \pkg{epstool} for cropping the graphics.
\item Direct support for \cmd\includegraphics\ with \EPS\ files.
\item Check for correct behaviour in shells other than bash.
\item More flexible usage (support things like |\begin{postscript}| in \pkg{pst-pdf}).
\item \pkg{mylatex} integration.
\end{enumerate}

\part{Implementation}
\parindent=0pt
\DocInput{pstool.sty}
\end{document}