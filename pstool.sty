\ProvidesPackage{pstool}[2008/08/08 v0.6
  Wrapper for processing PostScript/psfrag figures]

% External packages
\RequirePackage{%
  catchfile,color,ifpdf,ifplatform,
  inversepath,graphicx,suffix,xkeyval}

% Initialisations
\newif\if@pstool@always@
\newif\if@pstool@never@
\newif\if@pstool@pdfcrop@
\newif\if@pstool@nopreamble@
\newif\if@pstool@nofig@
\newwrite\pstool@out

% Package options
\DeclareOptionX{pdfcrop}{\@pstool@pdfcrop@true}

\define@choicekey*{pstool.sty}{process}[\@tempa\@tempb]{all,none,auto}{%
  \ifcase\@tempb\relax
    \@pstool@always@true
  \or
    \@pstool@never@true
  \or
  \fi}

\define@choicekey*{pstool.sty}{mode}[\@tempa\@tempb]{errorstop,nonstop,batch}{%
  \edef\pstool@mode{\@tempa mode}%
}
\ExecuteOptionsX{mode=batch}

\DeclareOptionX{cleanup}{\def\pstool@rm@files{#1}}
\ExecuteOptionsX{cleanup={.tex,.dvi,.ps,.pdf,.log,.aux,-blx.bib,.nav,.out,.snm,.toc,.mp}}

\DeclareOptionX{suffix}{\def\pstool@suffix{#1}}
\ExecuteOptionsX{suffix={-process}}

\ifshellescape\else
  \ExecuteOptionsX{process=none}
  \PackageWarning{pstool}{^^J\space\space%
    Package option [process=none] activated^^J\space\space
    because -shell-escape is not enabled.^^J%
    This warning occurred}
\fi

\ProcessOptionsX

% These are cute:
\providecommand\OnlyIfFileExists[2]{\IfFileExists{#1}{#2}{}}
\providecommand\NotIfFileExists[2]{\IfFileExists{#1}{}{#2}}

% Command line abstractions between platforms:
\edef\pstool@cmdsep{\ifwindows\string&\else\string;\fi\space}
\edef\pstool@rm@cmd{\ifwindows del \else rm -- \fi}

% Delete a file if it exists:
\newcommand\pstool@rm[1]{%
  \OnlyIfFileExists{\ip@directpath#1}{%
    \immediate\write18{%
      cd "\ip@directpath"\pstool@cmdsep\pstool@rm@cmd "#1"}}%
}

% Generic function to execute a command on the shell and pass its exit status back into \LaTeX. Any number of \cmd\pstool@exe\ statements can be made consecutively followed by \cmd\pstool@endprocess, which also takes an argument. If \emph{any} of the shell calls failed, then the execution immediately skips to the end and expands \cmd\pstool@error\ instead of the argument to \cmd\pstool@endprocess.
\def\pstool@exe#1#2{%
  \pstool@writestatus{#1}{#2}%
  \pstool@retrievestatus{#1}%
  \ifnum\pstool@status > \z@
    \PackageWarning{pstool}{Execution failed during process:^^J  #2^^J}%
    \expandafter\pstool@abort
  \fi}

% Edit this definition to print something else when graphic processing fails.
\def\pstool@error{\fbox{\parbox{\linewidth}{\color{red}\ttfamily\scshape
  An error occured processing graphic \upshape`\ip@directpath\ip@lastelement'}}}

\def\pstool@abort#1\pstool@endprocess{\pstool@error\@gobble}
\let\pstool@endprocess\@firstofone

% It is necessary while executing commands on the shell to write the exit status to a temporary file to test for failures in processing. (If all versions of |pdflatex| supported input pipes, things might be different.)
\def\pstool@writestatus#1#2{%
  \immediate\write18{%
    cd "#1" \pstool@cmdsep
    #2 \pstool@cmdsep
    \ifwindows
       call echo
         \string^\@percentchar ERRORLEVEL\string^\@percentchar
    \else
       echo \detokenize{$?}
    \fi
    > \pstool@statusfile}%
% That's the execution; now we need to flush the write buffer to the status file. This ensures the file is written to disk properly (allowing it to be read by \cmd\CatchFileEdef). Not necessary on Windows, whose file writing is evidently more crude/immediate.
  \ifwindows\else
    \immediate\write18{%
      touch #1\pstool@statusfile}%
  \fi}
\def\pstool@statusfile{statusfile-deleteme.txt}

% Read the exit status from the temporary file and delete it.\\
% |#1| is the path\\
% Status is recorded in \cmd\pstool@status.
\def\pstool@retrievestatus#1{%
  \CatchFileEdef{\pstool@status}{#1\pstool@statusfile}{}%
  \pstool@rm{\pstool@statusfile}%
  \ifx\pstool@status\pstool@statusfail
    \PackageWarning{pstool}{%
      Status of process unable to be determined:^^J  #1^^J%
      Trying to proceed... }%
    \def\pstool@status{0}%
  \fi}
\def\pstool@statusfail{\par }% what results when \TeX\ reads an empty file

% \subsection{File age detection}
% Use |ls| (or |dir|) to detect if the EPS is newer than the PDF.
\def\pstool@IfnewerEPS{%
  \edef\pstool@filenames{\ip@lastelement.eps\space \ip@lastelement.pdf\space}%
  \immediate\write18{%
    cd "\ip@directpath"\pstool@cmdsep
    \ifwindows
      dir /T:W /B /O-D "\ip@lastelement.eps" "\ip@lastelement.pdf" > \pstool@statusfile
    \else
      ls -t "\ip@lastelement.eps" "\ip@lastelement.pdf" > \pstool@statusfile
    \fi
  }%
  \pstool@retrievestatus{\ip@directpath}%
  \ifx\pstool@status\pstool@filenames
    \expandafter\@firstoftwo
  \else
    \expandafter\@secondoftwo
  \fi
}

% This is used later as a wrapper for \cs{inversepath*}. Long story short, always need a relative path to a filename even if it's in the same directory.
\def\pstool@inverse#1{%
  \edef\@tempa{\unexpanded{\inversepath*}{#1}}%
  \@tempa% calculate filename, path \& inverse path
  \ifx\ip@directpath\@empty
    \def\ip@directpath{./}%
  \fi
}

% \section{Command parsing}
% User input is \cmd\pstool\ (with optional |*| or |!| suffix) which turns into one of the following three macros depending on the mode.

\newcommand\pstool@alwaysprocess[3][]{%
  \pstool@inverse{#2}%
  \pstool@process{#1}{#2}{#3}}

\newcommand\pstool@neverprocess[3][]{%
  \includegraphics[#1]{#2}}

% For regular operation, which processes the figure only if
% the command is starred, or the PDF doesn't exist.
\newcommand\pstool@maybeprocess[3][]{%
  \pstool@inverse{#2}%
  \IfFileExists{#2.pdf}{%
    \pstool@IfnewerEPS{% needs info from |\pstool@inverse|
      \pstool@process{#1}{#2}{#3}%
    }{%
      \includegraphics[#1]{#2}%
    }%
  }{%
    \pstool@process{#1}{#2}{#3}%
  }}

% \subsection{User commands}
%  Finally, define \cmd\pstool\ as appropriate for the mode:
\ifpdf
  \if@pstool@always@
    \let\pstool\pstool@alwaysprocess
    \WithSuffix\def\pstool!{\pstool@alwaysprocess}
    \WithSuffix\def\pstool*{\pstool@alwaysprocess}
  \else\if@pstool@never@
    \let\pstool\pstool@neverprocess
    \WithSuffix\def\pstool!{\pstool@neverprocess}
    \WithSuffix\def\pstool*{\pstool@neverprocess}
  \else
    \let\pstool\pstool@maybeprocess
    \WithSuffix\def\pstool!{\pstool@neverprocess}
    \WithSuffix\def\pstool*{\pstool@alwaysprocess}
  \fi\fi
\else
  \let\pstool\pstool@neverprocess
  \WithSuffix\def\pstool!{\pstool@neverprocess}
  \WithSuffix\def\pstool*{\pstool@neverprocess}
\fi

% \section{The figure processing}

% \cmd\ip@lastelement\ is the filename of the figure stripped of its path (if any)
\def\pstool@jobname{\ip@lastelement\pstool@suffix}

\def\pstool@echo#1{\immediate\write18{echo "#1"}}

\newcommand\pstool@process[3]{%
  \pstool@echo{^^J^^J=== pstool: auxiliary process: \ip@lastelement\space ===}%
  \pstool@write@processfile{#1}{#2}{#3}%
  \pstool@exe{./}{latex
      -shell-escape
      -output-format=dvi
      -output-directory="\ip@directpath"
      -interaction=\pstool@mode\space
          "\pstool@jobname.tex"}%
  \pstool@echo{^^J=== pstool: dvips ===}%
  \pstool@exe{\ip@directpath}{%
    dvips "\pstool@jobname.dvi"}%
  \pstool@echo{^^J=== pstool: ps2pdf ===}%
  \if@pstool@pdfcrop@
    \pstool@exe{\ip@directpath}{%
      ps2pdf "\pstool@jobname.ps" "\pstool@jobname.pdf"}%
    \pstool@echo{^^J=== pstool: pdfcrop ===}%
    \pstool@exe{\ip@directpath}{%
      pdfcrop "\pstool@jobname.pdf" "\ip@lastelement.pdf"}%
  \else
    \pstool@exe{\ip@directpath}{%
      ps2pdf "\pstool@jobname.ps" "\ip@lastelement.pdf"}%
  \fi
  \pstool@echo{^^J=== pstool: end processing ===^^J}%
  \pstool@endprocess{%
    \pstool@cleanup
    \includegraphics[#1]{#2}}}

% The file that is written for processing is set up to read the preamble of the original document and set the graphic on an empty page (cropping to size is done either here with \pkg{preview} or later with \pkg{pdfcrop}).
\def\pstool@write@processfile#1#2#3{%
    \immediate\openout\pstool@out #2\pstool@suffix.tex\relax
    \immediate\write\pstool@out{%
      \noexpand\pdfoutput=0% force DVI mode if not already
%
% Input the main document; redefine the document environment so only the preamble is read:
      \if@pstool@nopreamble@
        \unexpanded{%
          \documentclass{minimal}
          \usepackage{graphicx}}
      \else
        \unexpanded{%
          \let\origdocument\document
          \let\EndPreamble\endinput
          \def\document{\endgroup\endinput}}%
        \noexpand\input{\jobname}%
      \fi
%
% Now the preamble of the process file: (restoring document's original meaning; empty \cmd\pagestyle\ removes the page number)
      \if@pstool@pdfcrop@\else
        \noexpand\usepackage[active,tightpage]{preview}
      \fi
      \if@pstool@nopreamble@\else
        \unexpanded{%
          \let\document\origdocument
          \pagestyle{empty}}%
      \fi
%
% And the document body to place the graphic on a page of its own:
      \unexpanded{%
        \begin{document}
        \centering\null\vfill}%
      \if@pstool@pdfcrop@\else
        \noexpand\begin{preview}%
      \fi
      \unexpanded{#3}% this is the "psfrag" material
      \if@pstool@nofig@\else
        \noexpand\includegraphics[#1]{\ip@lastelement}%
      \fi
      \if@pstool@pdfcrop@\else
        \noexpand\end{preview}%
      \fi
      \unexpanded{%
        \vfill\end{document}}%
      }%
    \immediate\closeout\pstool@out}

\def\pstool@cleanup{%
  \@for\@ii:=\pstool@rm@files\do{%
    \pstool@rm{\pstool@jobname\@ii}%
}}

\providecommand\EndPreamble{}

% \section{User commands}
%
% These all support the suffixes |*| and |!|, so each user command is defined as a wrapper to \cmd\pstool.

% for plain EPS figures (no psfrag):
\newcommand\epsfig[2][]{\pstool@epsfig{\pstool}[#1]{#2}}
\WithSuffix\newcommand\epsfig*[2][]{\pstool@epsfig{\pstool*}[#1]{#2}}
\WithSuffix\newcommand\epsfig![2][]{\pstool@epsfig{\pstool!}[#1]{#2}}

\def\pstool@epsfig#1[#2]#3{%
  \begingroup
    \@pstool@nopreamble@true
    #1[#2]{#3}{}%
  \endgroup
}

% for EPS figures with psfrag:
\newcommand\psfragfig[2][]{\pstool@psfragfig{#1}{#2}{\pstool}}
\WithSuffix\newcommand\psfragfig*[2][]{\pstool@psfragfig{#1}{#2}{\pstool*}}
\WithSuffix\newcommand\psfragfig![2][]{\pstool@psfragfig{#1}{#2}{\pstool!}}

\newcommand\pstool@psfragfig[3]{%
  \@ifnextchar\bgroup{%
    \pstool@@psfragfig{#1}{#2}{#3}%
  }{%
    \pstool@@psfragfig{#1}{#2}{#3}{}%
  }%
}

\newcommand\pstool@@psfragfig[4]{%
  \IfFileExists{#2-psfrag.eps}{%
    \def\pstool@eps{#2-psfrag}%
    \OnlyIfFileExists{#2.eps}{%
      \PackageWarning{pstool}{Graphic "#2.eps" exists but "#2-psfrag.eps" is being used}%
    }%
  }{%
    \IfFileExists{#2.eps}{%
      \def\pstool@eps{#2}%
    }{%
      \PackageError{pstool}{%
        No graphic "#2.eps" or "#2-psfrag.eps" found%
      }{%
        Check the path and whether the file exists.%
      }%
    }%
  }%
  #3[#1]{\pstool@eps}{%
    \InputIfFileExists{#2-psfrag.tex}{%
      \OnlyIfFileExists{#2.tex}{%
        \PackageWarning{pstool}{%
          File "#2.tex" exists that may contain macros for "\pstool@eps.eps"^^J%
          But file "#2-psfrag.tex" is being used instead.}%
      }%
    }{%
      \InputIfFileExists{#2.tex}{}{}%
    }%
    #4}%
}

% for Matlab's laprint:
\newcommand\laprintfig[2][]{\pstool@laprintfig{\pstool}[#1]{#2}}
\WithSuffix\newcommand\laprintfig*[2][]{\pstool@laprintfig{\pstool*}[#1]{#2}}
\WithSuffix\newcommand\laprintfig![2][]{\pstool@laprintfig{\pstool!}[#1]{#2}}

\def\pstool@laprintfig#1[#2]#3{%
  \begingroup
    \@pstool@nofig@true
    \renewcommand\resizebox[3]{##3}%
    \renewcommand\includegraphics[2][]{#1[#2]{##2}{}}%
    \input{#3}%
  \endgroup
}

